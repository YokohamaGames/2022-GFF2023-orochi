using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.InputSystem;
//敵のAiとステータス設定
public class Enemy : MonoBehaviour
{
    //敵のステータスに関する数値設定

    
    [SerializeField]
    private float ChaseSpeed;                              //敵の追跡時歩行スピードを設定

    [SerializeField]
    private float AttackReadySpeed = 1;                    //攻撃準備時の歩行スピードを設定  

    [SerializeField]
    private float TimetoAttack = 2;                        //攻撃準備から攻撃までの時間の設定

    [SerializeField]
    private Transform target;                              //追跡目標の設定

    [SerializeField]
    private Animator animator;

    
    //敵の回転速度を設定します
    [SerializeField]
    private float rotMax;
    //子オブジェクトを取得
    [SerializeField]
    private SearchArea searchArea;
    //子オブジェクトを取得
    [SerializeField]
    private AttackArea attackArea;

    float timetoattack;                                    //攻撃時間を設定した時間にリセットする変数
    

    public bool SearchArea = false;

    public bool AttackArea = false;
    float speed = 1;                                       //現在の敵の歩行スピード


    // コンポーネントを事前に参照しておく変数
    new Rigidbody rigidbody;
    //Animator animator;
    
    // AnimatorのパラメーターID
    static readonly int isDiscover = Animator.StringToHash("isDiscover");
    static readonly int isLost = Animator.StringToHash("isLost");
    static readonly int isAttackReady = Animator.StringToHash("isAttackReady");
    static readonly int isAttack = Animator.StringToHash("isAttack");

    


    enum EnemyState
    {
        //待機状態
        Stay,

        //発見状態
        Discover,

        //移動状態
        Move,

        //攻撃準備
        AttackReady,
        //攻撃状態
        Attack,

        //回避状態
        Escape,


    }

    EnemyState currentState = EnemyState.Stay;
    void Start()
    {
        //animator = GetComponent<Animator>();
        rigidbody = GetComponent<Rigidbody>();             
        timetoattack = TimetoAttack;                       //攻撃時間を指定した時間にリセットする変数に値を代入
        
    }

    // Update is called once per frame
    void Update()
    {
        {
            // 状態ごとの分岐処理
            switch (currentState)
            {
                case EnemyState.Stay:
                    UpdateForStay();
                    break;
                case EnemyState.Move:
                    UpdateForMove();
                    break;
                case EnemyState.Attack:
                    UpdateForAttack();
                    break;
                case EnemyState.Discover:
                    UpdateForDiscover();
                    break;
                case EnemyState.AttackReady:
                    UpdateForAttackReady();
                    break;
                default:
                    break;
            }

        }
        /*索敵範囲と攻撃範囲の中にいるとき攻撃モード
        if (SearchArea && AttackArea)
        {
            Debug.Log("攻撃範囲内");
        }
        //索敵範囲内のみの時追跡モード
        else if (SearchArea)
        {
            Debug.Log("索敵範囲内");
        }
        //索敵範囲外の時Stay
        else if (!SearchArea)
        {
            Debug.Log("索敵範囲外");
        }
        */
        
        //Debug.Log(TimeCount);

        

    }

    public void SetStayState()
    {
        currentState = EnemyState.Stay;
        animator.SetTrigger(isLost);
        
    }

    public void SetDiscoverState()
    {
        currentState = EnemyState.Discover;
        animator.SetTrigger(isDiscover);
    }
    public void SetMoveState()
    {
        currentState = EnemyState.Move;
        speed = ChaseSpeed;
    }
    public void SetAttackReadyState()
    {
        currentState = EnemyState.AttackReady;
        speed = 0;                                         //攻撃範囲に入ったら様子見で移動速度を小さくする
        animator.SetTrigger(isAttackReady);
        
    }
    public void SetAttackState()
    {
        currentState = EnemyState.Attack;
        speed = 0;
        timetoattack = TimetoAttack;                       ////攻撃までの時間のカウントをリセット

        animator.SetTrigger(isAttack);

    }
    public void SetEscapeState()
    {

    }
    //待機状態のアップデート処理
    void UpdateForStay()
    {
        //Debug.Log("待機中");
    }

    void UpdateForMove()
    {


       
        //ターゲット方向のベクトルを求める
        Vector3 vec = target.position - transform.position;

        // ターゲットの方向を向く
        // Quaternion(回転値)を取得
        Quaternion quaternion = Quaternion.LookRotation(vec);
        //transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(new Vector3(vec.x, 0, vec.z)), rotMax);
        rigidbody.velocity = new Vector3(0, 0, speed);  // 正面方向に移動

        // 算出した回転値をこのゲームオブジェクトのrotationに代入
        this.transform.rotation = quaternion;


    }
    //攻撃範囲にとどまっている時間をカウントして一定時間を超えたらAttackStateに切り替え、カウントを0にリセット
    void UpdateForAttackReady()
    {
        
        Debug.Log(timetoattack);
        timetoattack -= Time.deltaTime;
        
        if(0 > timetoattack)                               //攻撃までの時間が0になればステート遷移。カウントをリセットする。
        {
            
            SetAttackState();
        }
    }
    void UpdateForAttack()
    {

        //ターゲット方向のベクトルを求める
        Vector3 vec = target.position - transform.position;

        // ターゲットの方向を向く
        // Quaternion(回転値)を取得
        Quaternion quaternion = Quaternion.LookRotation(vec);
        //transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(new Vector3(vec.x, 0, vec.z)), rotMax);
        rigidbody.velocity = new Vector3(0, 0, speed);  // 正面方向に移動

        // 算出した回転値をこのゲームオブジェクトのrotationに代入
        this.transform.rotation = quaternion;


    }
    void UpdateForDiscover()
    {
        speed = ChaseSpeed;
        if(currentState == EnemyState.Discover)
        {
            //ターゲット方向のベクトルを求める
            Vector3 vec = target.position - transform.position;
            // Quaternion(回転値)を取得 回転する度数を取得
            Quaternion quaternion = Quaternion.LookRotation(vec);
            //取得した度数分オブジェクトを回転させる
            transform.rotation = quaternion;
            transform.Translate(Vector3.forward * speed * 0.01f); // 正面方向に移動

        }
    }
}






